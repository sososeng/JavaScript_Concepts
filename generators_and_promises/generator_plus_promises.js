async(function*(){ //The function using asynchronous results should be able to pause while waiting for results. Notice the function*. We’re using generators!
  try {
  	//Yield on each asynchronous task.
  	const ninjas = yield getJSON("test.js");
	const missions = yield getJSON(ninjas[0].missionsUrl);
	const missionDescription = yield getJSON(missions[0].detailsUrl); //Study the mission details
	}
  //We can still use all standard language constructs such as try-catch statements or loops.
  catch(e) {
  //Oh no, we weren't able to get the mission details 
  }
});

function async(generator) { //Defines a helper function that will control our generator
 	var iterator = generator(); //Creates an iterator through which we’ll control the generator

	function handle(iteratorResult) { //Defines the function that will handle each value generated by the generator
	 	if(iteratorResult.done) { return; } //Stops when the generator has no more results

	 	const iteratorValue = iteratorResult.value;
	 	//If the generated value is a promise, register a success and a failure callback. This is the asynchronous part. If the promise succeeds, great, resume the generator and send in the promised value. If there’s an error, throw an exception to the generator.
		if(iteratorValue instanceof Promise) {
			iteratorValue.then(res => handle(iterator.next(res))
				.catch(err => iterator.throw(err));

			} 
	}
	//Restarts the generator execution.
	try {
  		handle(iterator.next());
	}
		catch (e) { iterator.throw(e); }
}